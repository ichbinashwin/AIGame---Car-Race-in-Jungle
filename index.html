<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Snack Game ‚Äî Accessible, Responsive</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root{
      --bg1:#0d0d0f; --bg2:#1b1f3a; --accent:#ffeb3b; --snake:#4caf50; --btn-bg:rgba(255,255,255,.18);
      --btn-border:#ffffff; --canvas-border:#ffffff; --text:#ffffff;
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0}
    body{
      display:flex; flex-direction:column; background:#0d0d0f; color:var(--text);
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; overflow:hidden;
    }
    /* Header */
    #header{padding:10px 12px; text-align:center}
    #title{margin:0; font-size:clamp(20px,3.2vw,28px); color:var(--accent)}
    #hud{margin-top:6px; display:flex; gap:12px; justify-content:center; align-items:center}
    .btn-primary{
      appearance:none; border:none; border-radius:10px; padding:.6rem 1.1rem; font-size:1rem; cursor:pointer;
      background:#00c853; color:#000; font-weight:600
    }
    .btn-primary:focus-visible{outline:3px solid #fff}
    /* Game area */
    #game-wrap{flex:1; display:flex; align-items:center; justify-content:center; position:relative; padding:8px}
    canvas{display:block; border:4px solid var(--canvas-border); border-radius:12px; background:#0e0f14}
    #gameOver{
      position:absolute; inset:auto 50% 50% auto; transform:translate(50%,50%);
      background:rgba(0,0,0,.9); padding:18px 24px; border-radius:12px; display:none; text-align:center
    }
    #gameOver h2{margin:.2rem 0 1rem}
    /* Remote */
    #controls{
      padding:10px 6px 14px; display:grid; grid-template-columns:repeat(3,minmax(64px,96px));
      grid-template-rows:repeat(3,minmax(64px,96px)); gap:12px; justify-content:center; align-content:center;
    }
    .pad{display:flex; align-items:center; justify-content:center; border-radius:50%;
      border:3px solid var(--btn-border); background:var(--btn-bg); font-size:clamp(28px,6vw,36px);
      color:#fff; cursor:pointer; user-select:none; touch-action:manipulation; box-shadow:0 6px 16px rgba(0,0,0,.45)
    }
    .pad:active{transform:scale(.95); background:rgba(255,255,255,.32)}
    .pad:focus-visible{outline:4px solid #fff}
    /* Accessibility: ensure contrast of text */
    .sr-only{position:absolute; left:-9999px}
  </style>
</head>
<body>
  <div id="header">
    <h1 id="title">üêç Snack Game</h1>
    <div id="hud" role="status" aria-live="polite">
      <div id="score" aria-label="Current score">Score: 0</div>
      <button id="startBtn" class="btn-primary" aria-label="Start game">Start</button>
    </div>
  </div>

  <div id="game-wrap">
    <canvas id="game"></canvas>
    <div id="gameOver" role="dialog" aria-modal="true" aria-labelledby="goTitle">
      <h2 id="goTitle">Game Over</h2>
      <button id="restartBtn" class="btn-primary" aria-label="Restart game">Restart</button>
    </div>
  </div>

  <!-- On-screen remote -->
  <div id="controls" aria-label="Game controller">
    <div></div>
    <button class="pad" id="up" aria-label="Move up">‚¨Ü</button>
    <div></div>
    <button class="pad" id="left" aria-label="Move left">‚¨Ö</button>
    <div></div>
    <button class="pad" id="right" aria-label="Move right">‚û°</button>
    <div></div>
    <button class="pad" id="down" aria-label="Move down">‚¨á</button>
    <div></div>
  </div>

  <script>
    // === Canvas and layout sizing (bulletproof) ===
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d', { alpha: false });
    const header = document.getElementById('header');
    const controls = document.getElementById('controls');
    const scoreEl = document.getElementById('score');
    const startBtn = document.getElementById('startBtn');
    const restartBtn = document.getElementById('restartBtn');
    const gameOverBox = document.getElementById('gameOver');

    const cell = 20;              // grid size
    const minPx = 220;            // never shrink below this (prevents 0√ó0)
    let cols = 20, rows = 20;     // will be recalculated
    let tickMs = 190;             // speed (slower = bigger number)

    function sizeCanvas() {
      // Measure available area = viewport - header - controls - small margin
      const vw = Math.max(320, window.innerWidth);
      const vh = Math.max(320, window.innerHeight);
      const hH = header.getBoundingClientRect().height || 0;
      const cH = controls.getBoundingClientRect().height || 0;
      const availW = Math.max(minPx, vw - 16);
      const availH = Math.max(minPx, vh - hH - cH - 16);

      cols = Math.max(10, Math.floor(availW / cell));
      rows = Math.max(10, Math.floor(availH / cell));

      canvas.width  = cols * cell;
      canvas.height = rows * cell;
    }
    window.addEventListener('resize', () => { sizeCanvas(); if (!running) drawFrame(); });
    sizeCanvas();

    // === Background (different per user): accessible gradients ===
    const gradients = [
      ['#0d0d0f','#1b1f3a'], ['#0b1b17','#1d4736'], ['#0f1022','#2b2b55'], ['#101314','#223a46'],
      ['#0f1418','#243a2e'], ['#111218','#2a2b3e']
    ];
    const gPick = gradients[Math.floor(Math.random()*gradients.length)];
    function paintBackground(){
      const g = ctx.createLinearGradient(0,0,canvas.width,canvas.height);
      g.addColorStop(0,gPick[0]); g.addColorStop(1,gPick[1]);
      ctx.fillStyle = g; ctx.fillRect(0,0,canvas.width,canvas.height);
    }

    // === Game state ===
    let snake = [];
    let dir = 'RIGHT';
    let food = null;
    let score = 0;
    let timer = null;
    let running = false;
    let danceUntil = 0;
    // Optional food icon; draw fallback if not loaded
    const foodImg = new Image();
    foodImg.src = 'https://cdn-icons-png.flaticon.com/512/1998/1998610.png';
    let foodReady = false;
    foodImg.onload = () => foodReady = true;

    function startGame(){
      sizeCanvas(); // ensure current size
      // Center start; 3-block snake
      const startX = Math.floor(cols/2) * cell;
      const startY = Math.floor(rows/2) * cell;
      snake = [
        {x:startX, y:startY},
        {x:startX-cell, y:startY},
        {x:startX-2*cell, y:startY}
      ];
      dir = 'RIGHT';
      score = 0;
      updateScore();
      food = placeFood();
      danceUntil = 0;
      gameOverBox.style.display = 'none';
      startBtn.style.display = 'none';
      if (timer) clearInterval(timer);
      timer = setInterval(step, tickMs);
      running = true;
      drawFrame();
    }
    function gameOver(){
      running = false;
      if (timer) clearInterval(timer);
      gameOverBox.style.display = 'block';
    }
    function updateScore(){ scoreEl.textContent = 'Score: ' + score; }

    function placeFood(){
      // Find a cell not occupied by the snake
      let x, y, tries = 0;
      do{
        x = Math.floor(Math.random()*cols)*cell;
        y = Math.floor(Math.random()*rows)*cell;
        tries++;
        if (tries>500) break; // fallback
      } while (snake.some(s => s.x===x && s.y===y));
      return {x,y};
    }

    // Input (keyboard + on-screen)
    function changeDir(next){
      if (next==='LEFT'  && dir!=='RIGHT') dir='LEFT';
      if (next==='RIGHT' && dir!=='LEFT')  dir='RIGHT';
      if (next==='UP'    && dir!=='DOWN')  dir='UP';
      if (next==='DOWN'  && dir!=='UP')    dir='DOWN';
    }
    document.addEventListener('keydown', (e)=>{
      if (e.key==='ArrowLeft')  changeDir('LEFT');
      if (e.key==='ArrowRight') changeDir('RIGHT');
      if (e.key==='ArrowUp')    changeDir('UP');
      if (e.key==='ArrowDown')  changeDir('DOWN');
      if (!running && (e.key==='Enter' || e.key===' ')) startGame();
    });
    document.getElementById('up').addEventListener('click',   ()=>changeDir('UP'));
    document.getElementById('down').addEventListener('click', ()=>changeDir('DOWN'));
    document.getElementById('left').addEventListener('click', ()=>changeDir('LEFT'));
    document.getElementById('right').addEventListener('click',()=>changeDir('RIGHT'));
    document.getElementById('restartBtn').addEventListener('click', startGame);
    document.getElementById('startBtn').addEventListener('click', startGame);

    // Game tick
    function step(){
      // current head
      let hx = snake[0].x, hy = snake[0].y;
      if (dir==='LEFT')  hx -= cell;
      if (dir==='RIGHT') hx += cell;
      if (dir==='UP')    hy -= cell;
      if (dir==='DOWN')  hy += cell;

      // collisions (walls)
      if (hx<0 || hy<0 || hx>=canvas.width || hy>=canvas.height) return gameOver();

      const head = {x:hx, y:hy};
      // collisions (self)
      if (snake.some(seg => seg.x===head.x && seg.y===head.y)) return gameOver();

      // eat
      let grew = false;
      if (food && hx===food.x && hy===food.y){
        grew = true;
        score++;
        updateScore();
        food = placeFood();
        if (score>0 && score%10===0){ danceUntil = performance.now()+2000; }
      }
      // add new head
      snake.unshift(head);
      if (!grew) snake.pop();

      drawFrame();
    }

    // Render
    function drawFrame(){
      paintBackground();

      // Food
      if (food){
        if (foodReady){
          ctx.drawImage(foodImg, food.x, food.y, cell, cell);
        } else {
          // high-contrast fallback coin
          ctx.beginPath();
          ctx.arc(food.x+cell/2, food.y+cell/2, cell*0.42, 0, Math.PI*2);
          ctx.fillStyle = '#ffc400';
          ctx.fill();
          ctx.lineWidth = 2;
          ctx.strokeStyle = '#3a2b00';
          ctx.stroke();
        }
      }

      // Snake
      const dancing = performance.now() < danceUntil;
      for (let i=0;i<snake.length;i++){
        const seg = snake[i];
        let color;
        if (dancing){
          // wiggle palette with high contrast
          color = (i%2===0) ? '#ff5722' : '#ffeb3b';
        } else {
          color = (i===0) ? '#ffeb3b' : '#4caf50';
        }
        ctx.fillStyle = color;
        ctx.fillRect(seg.x, seg.y, cell, cell);
        ctx.strokeStyle = '#000000';
        ctx.lineWidth = 1.5;
        ctx.strokeRect(seg.x+0.5, seg.y+0.5, cell-1, cell-1);
      }

      // If not running yet, still show a clean board
      if (!running){
        // optional: hint text (kept short for accessibility)
        // (Not necessary for function)
      }
    }

    // Initial paint so you always see something immediately
    drawFrame();
  </script>
</body>
</html>